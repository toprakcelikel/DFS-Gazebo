import rclpy
from rclpy.node import Node
from geometry_msgs.msg import TwistStamped
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
import math

class DFSAutonomous(Node):
    def __init__(self):
        super().__init__('dfs_autonomous')
        
        if not self.has_parameter('use_sim_time'):
            self.declare_parameter('use_sim_time', True)

        self.cmd_pub = self.create_publisher(TwistStamped, '/cmd_vel', 10)
        self.odom_sub = self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        
        qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )
        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, qos)

        # Logical State
        self.visited = set()
        self.stack = []  
        self.target_cell = (0.0, 0.0)
        self.state = "SELECT_NEXT" 
        self.limit = 2  
        
        # Movement Variables
        self.current_x, self.current_y, self.yaw = 0.0, 0.0, 0.0
        self.home_x, self.home_y = None, None
        self.target_yaw = 0.0
        self.latest_distance = 10.0
        self.wait_until = 0.0

        self.timer = self.create_timer(0.05, self.control_loop)
        self.get_logger().info("start of Node")

    def scan_callback(self, msg):
        # Look at the front 180 degrees
        half_samples = len(msg.ranges) // 4
        front_arc = msg.ranges[-half_samples:] + msg.ranges[:half_samples]
        
        valid_ranges = [r for r in front_arc if 0.12 < r < msg.range_max]
        if valid_ranges:
            current_min = min(valid_ranges)
            if current_min < self.latest_distance:
                self.latest_distance = current_min

    def odom_callback(self, msg):
        rx, ry = msg.pose.pose.position.x, msg.pose.pose.position.y
        if self.home_x is None: 
            self.home_x, self.home_y = rx, ry
        self.current_x, self.current_y = rx - self.home_x, ry - self.home_y
        
        q = msg.pose.pose.orientation
        self.yaw = math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y * q.y + q.z * q.z))

    def control_loop(self):
        now = self.get_clock().now().nanoseconds / 1e9
        
        # STOP LOGIC
        if self.state == "FINISHED":
            self.cmd_pub.publish(TwistStamped()) # zero velocity
            return

        # 2. DETECTION TRIGGER
        if self.latest_distance < 0.25:
            self.cmd_pub.publish(TwistStamped()) 
            self.get_logger().info("I found it")
            self.state = "FINISHED" # Change state to stop all other logic
            return

        self.get_logger().info(f"STATUS: {self.state} | Pos: ({self.current_x:.1f},{self.current_y:.1f})", throttle_duration_sec=2.0)

        if now < self.wait_until:
            self.cmd_pub.publish(TwistStamped()) 
            return

        msg = TwistStamped()
        msg.header.stamp = self.get_clock().now().to_msg()
        
        grid_x, grid_y = round(self.current_x), round(self.current_y)
        dx = self.target_cell[0] - self.current_x
        dy = self.target_cell[1] - self.current_y
        dist = math.sqrt(dx**2 + dy**2)
        diff = math.degrees(math.atan2(math.sin(self.target_yaw - self.yaw), math.cos(self.target_yaw - self.yaw)))

        if self.state == "SELECT_NEXT":
            self.visited.add((grid_x, grid_y))
            neighbors = [(grid_x-1, grid_y), (grid_x+1, grid_y), (grid_x, grid_y+1), (grid_x, grid_y-1)]
            
            found = False
            for n in neighbors:
                if n not in self.visited and -self.limit <= n[0] <= self.limit and -self.limit <= n[1] <= self.limit:
                    self.stack.append((grid_x, grid_y))
                    self.target_cell = (float(n[0]), float(n[1]))
                    
                    if n[0] < grid_x: self.target_yaw = math.pi      
                    elif n[0] > grid_x: self.target_yaw = 0.0        
                    elif n[1] > grid_y: self.target_yaw = math.pi/2  
                    else: self.target_yaw = -math.pi/2               
                    
                    self.state = "ALIGN"
                    self.wait_until = now + 1.5
                    found = True
                    break
            
            if not found:
                if self.stack:
                    self.target_cell = self.stack.pop()
                    self.target_yaw = math.atan2(self.target_cell[1]-grid_y, self.target_cell[0]-grid_x)
                    self.state = "ALIGN"
                    self.wait_until = now + 1.5
                else: 
                    self.state = "FINISHED"
                    self.get_logger().info("DFS finished")

        elif self.state == "ALIGN":
            if abs(diff) > 0.5:
                speed = 0.35 if abs(diff) > 10.0 else 0.05
                msg.twist.angular.z = speed if diff > 0 else -speed
            else:
                self.state = "TRAVEL"
                self.wait_until = now + 1.0 

        elif self.state == "TRAVEL":
            msg.twist.angular.z = 0.8 * math.radians(diff) 
            if dist < 0.02:
                self.state = "SELECT_NEXT"
                self.wait_until = now + 1.5
            else:
                msg.twist.linear.x = 0.20
        
        self.cmd_pub.publish(msg)

def main():
    rclpy.init()
    node = DFSAutonomous()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        stop_msg = TwistStamped()
        node.cmd_pub.publish(stop_msg)
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()